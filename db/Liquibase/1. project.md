Below is a **full Spring Boot + Liquibase** project (banking-style) + **production rollback strategies** (what teams actually do).

---

# 1) Liquibase + Spring Boot full project

## Project structure

```
liquibase-banking/
 ├─ pom.xml
 └─ src/main/
    ├─ java/com/example/banking/
    │  ├─ BankingApplication.java
    │  ├─ api/AccountController.java
    │  ├─ api/dto/
    │  │  ├─ CreateAccountRequest.java
    │  │  ├─ MoneyRequest.java
    │  │  └─ AccountSummaryResponse.java
    │  ├─ domain/
    │  │  ├─ Account.java
    │  │  ├─ Txn.java
    │  │  └─ TxnType.java
    │  ├─ repo/
    │  │  ├─ AccountRepository.java
    │  │  └─ TxnRepository.java
    │  ├─ service/AccountService.java
    │  └─ web/GlobalExceptionHandler.java
    └─ resources/
       ├─ application.yml
       └─ db/changelog/
          ├─ db.changelog-master.yaml
          ├─ 001-init.yaml
          └─ 002-seed.yaml
```

---

## `pom.xml`

```xml
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>

  <parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-parent</artifactId>
    <version>3.3.5</version>
    <relativePath/>
  </parent>

  <groupId>com.example</groupId>
  <artifactId>liquibase-banking</artifactId>
  <version>1.0.0</version>
  <properties>
    <java.version>17</java.version>
  </properties>

  <dependencies>
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-web</artifactId>
    </dependency>

    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-validation</artifactId>
    </dependency>

    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-data-jpa</artifactId>
    </dependency>

    <!-- Liquibase -->
    <dependency>
      <groupId>org.liquibase</groupId>
      <artifactId>liquibase-core</artifactId>
    </dependency>

    <!-- H2 runtime -->
    <dependency>
      <groupId>com.h2database</groupId>
      <artifactId>h2</artifactId>
      <scope>runtime</scope>
    </dependency>

    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-test</artifactId>
      <scope>test</scope>
    </dependency>
  </dependencies>

  <build>
    <plugins>
      <plugin>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-maven-plugin</artifactId>
      </plugin>
    </plugins>
  </build>
</project>
```

---

## `application.yml` (important: ddl-auto none)

```yml
server:
  port: 8080

spring:
  datasource:
    url: jdbc:h2:mem:bankdb;MODE=PostgreSQL;DB_CLOSE_DELAY=-1;DATABASE_TO_UPPER=false
    driverClassName: org.h2.Driver
    username: sa
    password:

  jpa:
    hibernate:
      ddl-auto: none   # ✅ Liquibase owns schema
    properties:
      hibernate:
        format_sql: true

  liquibase:
    enabled: true
    change-log: classpath:db/changelog/db.changelog-master.yaml

  h2:
    console:
      enabled: true
      path: /h2-console
```

---

## Liquibase changelogs

### `db/changelog/db.changelog-master.yaml`

```yaml
databaseChangeLog:
  - include:
      file: db/changelog/001-init.yaml
  - include:
      file: db/changelog/002-seed.yaml
```

### `db/changelog/001-init.yaml` (schema + rollback)

```yaml
databaseChangeLog:
  - changeSet:
      id: 001-create-accounts
      author: saddam
      changes:
        - createTable:
            tableName: accounts
            columns:
              - column:
                  name: id
                  type: BIGINT
                  autoIncrement: true
                  constraints:
                    primaryKey: true
                    nullable: false
              - column:
                  name: account_no
                  type: VARCHAR(32)
                  constraints:
                    nullable: false
                    unique: true
              - column:
                  name: owner_name
                  type: VARCHAR(120)
                  constraints:
                    nullable: false
              - column:
                  name: balance
                  type: DECIMAL(19,2)
                  defaultValueNumeric: 0.00
                  constraints:
                    nullable: false
              - column:
                  name: created_at
                  type: TIMESTAMP
                  defaultValueComputed: CURRENT_TIMESTAMP
                  constraints:
                    nullable: false
      rollback:
        - dropTable:
            tableName: accounts

  - changeSet:
      id: 002-create-txns
      author: saddam
      changes:
        - createTable:
            tableName: txns
            columns:
              - column:
                  name: id
                  type: BIGINT
                  autoIncrement: true
                  constraints:
                    primaryKey: true
                    nullable: false
              - column:
                  name: account_id
                  type: BIGINT
                  constraints:
                    nullable: false
              - column:
                  name: type
                  type: VARCHAR(20)
                  constraints:
                    nullable: false
              - column:
                  name: amount
                  type: DECIMAL(19,2)
                  constraints:
                    nullable: false
              - column:
                  name: note
                  type: VARCHAR(255)
              - column:
                  name: created_at
                  type: TIMESTAMP
                  defaultValueComputed: CURRENT_TIMESTAMP
                  constraints:
                    nullable: false

        - addForeignKeyConstraint:
            baseTableName: txns
            baseColumnNames: account_id
            referencedTableName: accounts
            referencedColumnNames: id
            constraintName: fk_txn_account

        - createIndex:
            tableName: txns
            indexName: idx_txns_account_id
            columns:
              - column:
                  name: account_id

      rollback:
        - dropTable:
            tableName: txns
```

### `db/changelog/002-seed.yaml` (data + rollback)

```yaml
databaseChangeLog:
  - changeSet:
      id: 003-seed-demo-account
      author: saddam
      changes:
        - insert:
            tableName: accounts
            columns:
              - column: { name: account_no, value: "ACC-1001" }
              - column: { name: owner_name, value: "Demo User" }
              - column: { name: balance, valueNumeric: 5000.00 }

        # Add a seed txn using SQL because we need account_id lookup
        - sql:
            sql: |
              INSERT INTO txns (account_id, type, amount, note)
              SELECT id, 'DEPOSIT', 5000.00, 'Initial seed'
              FROM accounts
              WHERE account_no='ACC-1001';

      rollback:
        - sql:
            sql: |
              DELETE FROM txns WHERE note='Initial seed';
              DELETE FROM accounts WHERE account_no='ACC-1001';
```

---

## Java code (same API as Flyway version)

### `BankingApplication.java`

```java
package com.example.banking;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class BankingApplication {
  public static void main(String[] args) {
    SpringApplication.run(BankingApplication.class, args);
  }
}
```

### Domain

`TxnType.java`

```java
package com.example.banking.domain;
public enum TxnType { DEPOSIT, WITHDRAW }
```

`Account.java`

```java
package com.example.banking.domain;

import jakarta.persistence.*;
import java.math.BigDecimal;
import java.time.Instant;

@Entity
@Table(name = "accounts")
public class Account {
  @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
  private Long id;

  @Column(name="account_no", nullable=false, unique=true, length=32)
  private String accountNo;

  @Column(name="owner_name", nullable=false, length=120)
  private String ownerName;

  @Column(nullable=false, precision=19, scale=2)
  private BigDecimal balance = BigDecimal.ZERO;

  @Column(name="created_at", nullable=false, updatable=false)
  private Instant createdAt;

  @PrePersist
  void prePersist() {
    if (createdAt == null) createdAt = Instant.now();
    if (balance == null) balance = BigDecimal.ZERO;
  }

  public Long getId() { return id; }
  public String getAccountNo() { return accountNo; }
  public void setAccountNo(String accountNo) { this.accountNo = accountNo; }
  public String getOwnerName() { return ownerName; }
  public void setOwnerName(String ownerName) { this.ownerName = ownerName; }
  public BigDecimal getBalance() { return balance; }
  public void setBalance(BigDecimal balance) { this.balance = balance; }
  public Instant getCreatedAt() { return createdAt; }
}
```

`Txn.java`

```java
package com.example.banking.domain;

import jakarta.persistence.*;
import java.math.BigDecimal;
import java.time.Instant;

@Entity
@Table(name = "txns")
public class Txn {
  @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
  private Long id;

  @ManyToOne(fetch = FetchType.LAZY, optional = false)
  @JoinColumn(name = "account_id", nullable = false)
  private Account account;

  @Enumerated(EnumType.STRING)
  @Column(nullable=false, length=20)
  private TxnType type;

  @Column(nullable=false, precision=19, scale=2)
  private BigDecimal amount;

  @Column(length=255)
  private String note;

  @Column(name="created_at", nullable=false, updatable=false)
  private Instant createdAt;

  @PrePersist
  void prePersist() { if (createdAt == null) createdAt = Instant.now(); }

  public Long getId() { return id; }
  public Account getAccount() { return account; }
  public void setAccount(Account account) { this.account = account; }
  public TxnType getType() { return type; }
  public void setType(TxnType type) { this.type = type; }
  public BigDecimal getAmount() { return amount; }
  public void setAmount(BigDecimal amount) { this.amount = amount; }
  public String getNote() { return note; }
  public void setNote(String note) { this.note = note; }
  public Instant getCreatedAt() { return createdAt; }
}
```

### Repos

`AccountRepository.java`

```java
package com.example.banking.repo;

import com.example.banking.domain.Account;
import org.springframework.data.jpa.repository.JpaRepository;
import java.util.Optional;

public interface AccountRepository extends JpaRepository<Account, Long> {
  Optional<Account> findByAccountNo(String accountNo);
  boolean existsByAccountNo(String accountNo);
}
```

`TxnRepository.java`

```java
package com.example.banking.repo;

import com.example.banking.domain.Txn;
import org.springframework.data.jpa.repository.JpaRepository;
import java.util.List;

public interface TxnRepository extends JpaRepository<Txn, Long> {
  List<Txn> findTop20ByAccount_AccountNoOrderByCreatedAtDesc(String accountNo);
}
```

### DTOs

`CreateAccountRequest.java`

```java
package com.example.banking.api.dto;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;

public record CreateAccountRequest(
    @NotBlank @Size(min=4, max=32) String accountNo,
    @NotBlank @Size(min=2, max=120) String ownerName
) {}
```

`MoneyRequest.java`

```java
package com.example.banking.api.dto;

import jakarta.validation.constraints.DecimalMin;
import jakarta.validation.constraints.NotNull;
import java.math.BigDecimal;

public record MoneyRequest(
    @NotNull @DecimalMin("0.01") BigDecimal amount,
    String note
) {}
```

`AccountSummaryResponse.java`

```java
package com.example.banking.api.dto;

import java.math.BigDecimal;
import java.time.Instant;
import java.util.List;

public record AccountSummaryResponse(
    String accountNo,
    String ownerName,
    BigDecimal balance,
    Instant createdAt,
    List<TxnItem> lastTxns
) {
  public record TxnItem(String type, BigDecimal amount, String note, Instant createdAt) {}
}
```

### Service

`AccountService.java`

```java
package com.example.banking.service;

import com.example.banking.api.dto.AccountSummaryResponse;
import com.example.banking.domain.*;
import com.example.banking.repo.*;
import jakarta.transaction.Transactional;
import org.springframework.stereotype.Service;

import java.math.BigDecimal;
import java.util.List;

@Service
public class AccountService {
  private final AccountRepository accountRepo;
  private final TxnRepository txnRepo;

  public AccountService(AccountRepository accountRepo, TxnRepository txnRepo) {
    this.accountRepo = accountRepo;
    this.txnRepo = txnRepo;
  }

  @Transactional
  public Account createAccount(String accountNo, String ownerName) {
    if (accountRepo.existsByAccountNo(accountNo)) {
      throw new IllegalArgumentException("Account already exists: " + accountNo);
    }
    Account a = new Account();
    a.setAccountNo(accountNo);
    a.setOwnerName(ownerName);
    a.setBalance(BigDecimal.ZERO);
    return accountRepo.save(a);
  }

  @Transactional
  public Account deposit(String accountNo, BigDecimal amount, String note) {
    Account a = accountRepo.findByAccountNo(accountNo)
        .orElseThrow(() -> new IllegalArgumentException("Account not found: " + accountNo));
    a.setBalance(a.getBalance().add(amount));

    Txn t = new Txn();
    t.setAccount(a);
    t.setType(TxnType.DEPOSIT);
    t.setAmount(amount);
    t.setNote(note);
    txnRepo.save(t);

    return a;
  }

  @Transactional
  public Account withdraw(String accountNo, BigDecimal amount, String note) {
    Account a = accountRepo.findByAccountNo(accountNo)
        .orElseThrow(() -> new IllegalArgumentException("Account not found: " + accountNo));
    if (a.getBalance().compareTo(amount) < 0) {
      throw new IllegalStateException("Insufficient balance. Current balance: " + a.getBalance());
    }
    a.setBalance(a.getBalance().subtract(amount));

    Txn t = new Txn();
    t.setAccount(a);
    t.setType(TxnType.WITHDRAW);
    t.setAmount(amount);
    t.setNote(note);
    txnRepo.save(t);

    return a;
  }

  @Transactional
  public AccountSummaryResponse summary(String accountNo) {
    Account a = accountRepo.findByAccountNo(accountNo)
        .orElseThrow(() -> new IllegalArgumentException("Account not found: " + accountNo));

    List<AccountSummaryResponse.TxnItem> items =
        txnRepo.findTop20ByAccount_AccountNoOrderByCreatedAtDesc(accountNo).stream()
            .map(tx -> new AccountSummaryResponse.TxnItem(
                tx.getType().name(), tx.getAmount(), tx.getNote(), tx.getCreatedAt()
            ))
            .toList();

    return new AccountSummaryResponse(a.getAccountNo(), a.getOwnerName(), a.getBalance(), a.getCreatedAt(), items);
  }
}
```

### Controller

`AccountController.java`

```java
package com.example.banking.api;

import com.example.banking.api.dto.*;
import com.example.banking.domain.Account;
import com.example.banking.service.AccountService;
import jakarta.validation.Valid;
import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/accounts")
public class AccountController {
  private final AccountService service;

  public AccountController(AccountService service) { this.service = service; }

  @PostMapping
  @ResponseStatus(HttpStatus.CREATED)
  public Account create(@Valid @RequestBody CreateAccountRequest req) {
    return service.createAccount(req.accountNo().trim(), req.ownerName().trim());
  }

  @PostMapping("/{accountNo}/deposit")
  public Account deposit(@PathVariable String accountNo, @Valid @RequestBody MoneyRequest req) {
    return service.deposit(accountNo.trim(), req.amount(), req.note());
  }

  @PostMapping("/{accountNo}/withdraw")
  public Account withdraw(@PathVariable String accountNo, @Valid @RequestBody MoneyRequest req) {
    return service.withdraw(accountNo.trim(), req.amount(), req.note());
  }

  @GetMapping("/{accountNo}/summary")
  public AccountSummaryResponse summary(@PathVariable String accountNo) {
    return service.summary(accountNo.trim());
  }
}
```

### Error handler

`GlobalExceptionHandler.java`

```java
package com.example.banking.web;

import org.springframework.http.HttpStatus;
import org.springframework.http.ProblemDetail;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.*;

import java.util.HashMap;
import java.util.Map;

@RestControllerAdvice
public class GlobalExceptionHandler {

  @ExceptionHandler(MethodArgumentNotValidException.class)
  @ResponseStatus(HttpStatus.BAD_REQUEST)
  public ProblemDetail handleValidation(MethodArgumentNotValidException ex) {
    ProblemDetail pd = ProblemDetail.forStatus(HttpStatus.BAD_REQUEST);
    pd.setTitle("Validation error");
    Map<String, String> errors = new HashMap<>();
    ex.getBindingResult().getFieldErrors().forEach(fe -> errors.put(fe.getField(), fe.getDefaultMessage()));
    pd.setProperty("errors", errors);
    return pd;
  }

  @ExceptionHandler(IllegalArgumentException.class)
  @ResponseStatus(HttpStatus.NOT_FOUND)
  public ProblemDetail handleNotFound(IllegalArgumentException ex) {
    ProblemDetail pd = ProblemDetail.forStatus(HttpStatus.NOT_FOUND);
    pd.setTitle("Not found");
    pd.setDetail(ex.getMessage());
    return pd;
  }

  @ExceptionHandler(IllegalStateException.class)
  @ResponseStatus(HttpStatus.BAD_REQUEST)
  public ProblemDetail handleBadRequest(IllegalStateException ex) {
    ProblemDetail pd = ProblemDetail.forStatus(HttpStatus.BAD_REQUEST);
    pd.setTitle("Bad request");
    pd.setDetail(ex.getMessage());
    return pd;
  }
}
```

---

## Run

```bash
mvn clean test
mvn spring-boot:run
```

Try:

```bash
curl http://localhost:8080/api/accounts/ACC-1001/summary
```

---

# 2) Rollback strategies in production (real talk)

In production, DB rollback is scary because **data may already exist in the new shape**. So teams use these strategies:

## Strategy A: Fix-forward (most common)

Instead of rolling back DB, you ship a **new changeSet** to correct it.

Example: wrong column type → new changeSet alters type.

✅ safest
✅ audit-friendly
✅ no data loss

---

## Strategy B: Expand → Migrate → Contract (zero-downtime)

Used for column rename / big change.

1. **Expand**: add new column/table (don’t break old code)
2. **Migrate**: backfill data + deploy app reading new field
3. **Contract**: drop old column later

✅ supports rolling back the *application* without breaking DB
✅ best for microservices / multi-instance

---

## Strategy C: App rollback only (DB compatible changes)

You design DB changes to be **backward compatible**.

Example:

* adding nullable column
* adding new table
* adding index

If app deploy fails → rollback app version, DB stays.

✅ very common
⚠️ avoid destructive DB changes in same release

---

## Strategy D: Liquibase rollback (use carefully)

Liquibase supports `rollback:` blocks (like we added).

But in prod:

* rollback may delete columns/tables (data loss)
* rollback may be slow/locking

So teams use rollback mostly for:

* staging
* controlled incidents
* very small changes

---

## Strategy E: Restore from backup (last resort)

When corruption happens or big mistake:

* restore snapshot
* re-apply safe migrations

✅ reliable
❌ downtime + possible data loss since last backup

---

## Best practice rule set (banking-style)

* Keep migrations **small**
* Prefer **backward-compatible** changes
* Never drop/rename in same release (use expand/contract)
* Always test on a prod-like copy
* Treat rollback as **exception**, not plan A

---

If you want, I can add to this project:

* PostgreSQL + Docker Compose profile
* Liquibase “preconditions” (avoid running on wrong DB)
* CI check that fails build if changelog is invalid
* A real expand/migrate/contract example (rename column safely)
