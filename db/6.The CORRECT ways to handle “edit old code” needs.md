Perfect â€” this is **where people either become professionals or break production** ğŸ™‚
Iâ€™ll explain **ALL correct patterns**, with **why**, **when**, and **how**.

---

# Why â€œediting old migrationâ€ is a problem

Once a migration runs on **any shared DB (QA / prod)**:

* Flyway stores a **checksum**
* That migration becomes **immutable**
* Editing it = **history rewrite**
* Startup will FAIL

So teams treat migrations like **Git commits**:

> **append-only, never rewritten**

---

# âœ… ALL CORRECT ways to handle â€œedit old migrationâ€ needs

---

## 1ï¸âƒ£ Create a NEW migration (DEFAULT & BEST)

### When to use

* Requirements changed
* Column constraint wrong
* Need to modify schema logic

### Example

Old migration (already applied):

```sql
-- V2__add_status.sql
ALTER TABLE accounts ADD COLUMN status VARCHAR(20);
```

New requirement:

* status must be NOT NULL
* default = ACTIVE

âŒ Donâ€™t edit V2
âœ… Add **V3**

```sql
-- V3__enforce_status_not_null.sql
UPDATE accounts SET status = 'ACTIVE' WHERE status IS NULL;

ALTER TABLE accounts
ALTER COLUMN status SET NOT NULL;
```

### Why this is correct

âœ” Safe
âœ” Auditable
âœ” Works in prod
âœ” No data loss

---

## 2ï¸âƒ£ Fix-forward strategy (PRODUCTION STANDARD)

### Mindset

> **Never rollback prod unless legally required**
> Always move forward safely.

### Scenario

You deployed:

```sql
DECIMAL(5,2)
```

But business needs:

```sql
DECIMAL(7,2)
```

âŒ Rollback migration
âŒ Edit old SQL

âœ… Fix forward

```sql
-- V7__fix_interest_rate_precision.sql
ALTER TABLE accounts
ALTER COLUMN interest_rate TYPE DECIMAL(7,2);
```

### Why

* Rollback risks data loss
* Fix-forward preserves data
* Industry standard

---

## 3ï¸âƒ£ Split migrations for safety (ADVANCED)

### Problem

You want:

```sql
ADD COLUMN status VARCHAR(20) NOT NULL;
```

But DB already has data â†’ migration fails âŒ

### Correct pattern

#### Step 1 â€“ Add column nullable

```sql
-- V10__add_status_nullable.sql
ALTER TABLE accounts ADD COLUMN status VARCHAR(20);
```

#### Step 2 â€“ Backfill

```sql
-- V11__backfill_status.sql
UPDATE accounts SET status = 'ACTIVE' WHERE status IS NULL;
```

#### Step 3 â€“ Enforce constraint

```sql
-- V12__status_not_null.sql
ALTER TABLE accounts ALTER COLUMN status SET NOT NULL;
```

### Why

âœ” Zero downtime
âœ” Safe for large tables
âœ” Used in banks

---

## 4ï¸âƒ£ Rename column safely (ZERO-DOWNTIME)

### âŒ Wrong

```sql
ALTER TABLE accounts RENAME COLUMN phone TO phone_number;
```

This breaks running apps.

### âœ… Correct pattern

#### Step 1 â€“ Add new column

```sql
-- V20__add_phone_number.sql
ALTER TABLE accounts ADD COLUMN phone_number VARCHAR(20);
```

#### Step 2 â€“ Copy data

```sql
-- V21__copy_phone_data.sql
UPDATE accounts SET phone_number = phone;
```

#### Step 3 â€“ Deploy app using new column

#### Step 4 â€“ Drop old column

```sql
-- V22__drop_old_phone.sql
ALTER TABLE accounts DROP COLUMN phone;
```

---

## 5ï¸âƒ£ Baseline existing database (LEGACY SYSTEMS)

### When

* DB already exists
* No migration history
* Youâ€™re introducing Flyway now

### How

```yml
spring.flyway.baseline-on-migrate: true
spring.flyway.baseline-version: 1
```

Flyway:

* Marks current DB as version 1
* Starts tracking from there

âš ï¸ Use ONCE.

---

## 6ï¸âƒ£ Repair (DEV / TEST ONLY âš ï¸)

### When

* You edited migration accidentally
* Only local DB affected

```bash
mvn flyway:repair
```

### What it does

* Updates checksum in history table

âŒ Never in prod
âŒ Never in shared DB

---

## 7ï¸âƒ£ Delete & recreate DB (LOCAL DEV ONLY)

### When

* Early development
* No shared users

```bash
rm bankdb.mv.db
```

Flyway reruns everything cleanly.

---

# Decision table (print this ğŸ§ )

| Situation           | Correct action     |
| ------------------- | ------------------ |
| Change schema logic | New migration      |
| Prod mistake        | Fix-forward        |
| Add NOT NULL        | Split migrations   |
| Rename column       | Add â†’ copy â†’ drop  |
| Legacy DB           | Baseline           |
| Local mistake       | Repair / delete DB |
| Shared env          | Never edit old     |

---

# Interview-ready answer ğŸ¯

> Flyway migrations are append-only. Once applied, they must never be edited. Any change or correction is handled by creating a new migration that fixes or extends the previous behavior, ensuring safety, auditability, and production stability.

---

# Final mental model (lock this in)

> **Migrations = database history**
> **History is never rewritten â€” only extended**

---

If you want next:

* ğŸ§ª testing migrations in CI
* ğŸ” multi-instance Flyway locking
* ğŸš€ blueâ€“green DB migrations
* ğŸ“¦ Flyway + Kubernetes patterns

Just tell me ğŸ‘
